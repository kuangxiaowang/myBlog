---
title: 面试题整理
date: 2020-10-15 21:00:00
tags: 
      - 面试
      - 学习
categories: 面试
---

### HTML+CSS

#### 1  双飞翼 ，圣杯布局

```
1 弹性盒子
2 百分比 
3 定位
```

```
圣杯布局
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            margin:0;
            padding:0;
        }
        html{
            font-size: 31.25vw;
        }
        html,body{
            height: 100%;
        }
        body{
            display: flex;
        }
        header{
            width:1rem;
            height: 1rem;
            background: red;
        }
        main{
            flex: 1;
            width: 100%;
            height: 2rem;
            background: yellow;
        }
        footer{
            width:1rem;
            height: 1rem;
            background: springgreen;
        }
    </style>
</head>
<body>
    <header></header>
    <main></main>
    <footer></footer>
</body>
</html>
```
<!-- more -->
```
BFC双飞翼布局
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            margin:0;
            padding:0;
        }
        html,body{
            height: 100%;
        }
        .left{
            width: 200px;
            height: 60%;
            background: red;
            float: left;
        }
        .right{
            width: 200px;
            height: 60%;
            background: orange;
            float: right;
        }
        .center{
            height: 100%;
            background: green;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <!-- 双飞翼布局注意：布局的中间部分，一定在body里面写在最后面
    先写left和right;后写中间！！！必须这样子！！ -->
    <div class="left"></div>
    <div class="right"></div>
    <div class="center"></div>
</body>
</html>
```

```
不用BFC来写双飞翼布局
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            margin:0;
            padding:0;
        }
        html,body{
            height: 100%;
        }
        .left{
            width: 200px;
            height: 60%;
            background: red;
            float: left;
        }
        .right{
            width: 200px;
            height: 65%;
            background: orange;
            float: right;
        }
        .center{
            height: 100%;
            background: green;
            padding:0 200px;
        }
        .cenCon{
            height: 100%;
            background: purple;
        }
    </style>
</head>
<body>
    <!-- 双飞翼布局注意：布局的中间部分，一定在body里面写在最后面
    先写left和right;后写中间！！！必须这样子！！ -->
    <div class="left"></div>
    <div class="right"></div>
    <div class="center">
        <div class="cenCon"></div>
    </div>
</body>
</html>
```

#### 2  块元素垂直居中

```
1  弹性布局   ---  
2  定位    50% 50%  减自身的一ban
3  转行内块元素   line-height:100px  font-size:元素的高度    text-align：center
4  把定位改成 transform 
```

```
1  弹性布局
display:flex;
justify-content: center;
align-items: center;
```

```
2  定位
position: absolute;
left:50%;
top:50%;
margin:-高度的一半 0 0 -宽度的一半。
```

```
3  转行内块元素
text-align：center;
line-height:100px;
height:100px;
```

```
4  定位
position:absolute;
left:0;right:0;
top:0;bottom:0;
margin:auto;
```

#### 3  盒模型和怪异盒模型

```
普通盒模型     content + border*2 + paddign*2+margin*2 =  普通盒模型
怪异盒模型     contnet + margin*2   = 怪异盒模型  
```

```
1.两者区别

标准盒模型总宽度 = width + 左右padding + 左右border + 左右margin

标准盒模型总高度 = height + 上下padding + 上下border + 上下margin

怪异盒模型总宽度 = width + 左右margin (width包含了padding和border)

怪异盒模型总高度 = height + 上下margin (height包含了padding和border)

注：当没有添加文档声明时，就会触发某些浏览器的怪异模式，如IE6

2.如何将标准盒模型转换为怪异盒模型

给给标准盒子加上这个属性：

语法：box-sizing:border-box;

注：box-sizing:content-box;  默认值
```

#### 4 解决浮动塌陷  

```
1 清除浮动
2 overflow:hidden
3 给父元素添加高度
4 给父元素加边框
5 给父元素加padding
6 :after 给添加清除浮动
```

```
方法1: 给父元素加overflow:hidden;
方法2: 在浮动元素下面加空div,并添加样式
       div{
       	clear:both;
       	height:0; 
       	overflow:hidden;
       	}
方法3: 万能清除浮动法：
    选择符：after{
           	content: '';
           	clear: both;
           	display:block;
           	height:0;
           	visibility:hidden;
           	overflow: hidden;
           }
```

#### 5 em ，rem , px,  vw,vh

```
1 em   父元素的倍数
2 rem  根元素的倍数     （适配会根据rem来设定）  动态设置  html的font-size
3 vw,vh   只适用于高版本浏览器  ie9以上   移动都可以用  【100%内核都是 -webkit-】
4 px像素
```

```
1 px就是像素，也是我们现在经常使用的基本单位，比如常常听到的电脑像素是1024x768的，表示的是水平方向是1024个像素点，垂直方向是768个像素点。
2 em参考物是父元素的font-size，默认字体大小是16px，所以1em不是固定值，因为它会继承父元素的字体大小
3 rem参考物是相对于根元素，我们在使用时可以在根元素设置一个参考值即可，相对于em使用，减少很大运算工作量，例：html大小为10px，12rem就是120px。
4 % 是相对于父元素的大小设定的比率。
5 vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100
假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）
6 vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100
假如浏览器的高度为500px，那么1vh就等于5px（500px/100）
```

####  6 边框一像素问题

```
tarnsfrom : scale(0.7)  缩放
```

```
解决问题:移动端1像素变粗
	为什么移动端CSS里面写了1px，实际上看起来比1px粗；了解设备物理像素和逻辑像素的同学应该很容易理解，其实这两个px的含义其实是不一样的，UI设计师要求的1px是指设备的物理像素1px，而CSS里记录的像素是逻辑像素，它们之间存在一个比例关系，可以用javascript中的`window.devicePixelRatio`来获取，也可以用媒体查询的`-webkit-min-device-pixel-ratio`来获取。当然，比例多少与设备相关。在手机上border无法达到我们想要的效果。这是因为devicePixelRatio特性导致，iPhone的devicePixelRatio==2，而border-width: 1px描述的是设备独立像素，所以，border被放大到物理像素2px显示，在iPhone上就显得较粗。
解决方案:transform: scale(0.5) 方案，用高度1px的div充当边框
     div {
            height: 1px;
            background: #000;
            overflow: hidden;
        }
        /* 2倍屏 */
        @media only screen and (-webkit-min-device-pixel-ratio: 2.0) {
            div {
                -webkit-transform: scaleY(0.5);
                transform: scaleY(0.5);
            }
        }
        /* 3倍屏 */
        @media only screen and (-webkit-min-device-pixel-ratio: 3.0) {
            div {
                -webkit-transform: scaleY(0.33);
                transform: scaleY(0.33);
            }
        }
```

作者：果汁凉茶丶
链接：https://www.jianshu.com/p/fa670b737a29
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

####  7  兼容问题 

  链接1   https://blog.csdn.net/Jkssns/article/details/103456913   

```
1、IOS下input默认样式(圆角、阴影)
解决方案
input {
  -webkit-appearance: none;
  border-radius: 0;
  border: 1px #ccc solid;
}

2、在IOS下页面滑动卡顿，Android没问题
解决方案
body {-webkit-overflow-scrolling:touch; overflow-scrolling: touch;}

3、input type 改为button
当input type为button，disabled为true，会出现背景色异常(其实就是禁用的样式)
把input的disabled改为readonly
opacity：1

4、input type=text切换到英文输入法IOS下的问题
解决方案
input添加autocapitalize属性
<input class="SmallFour" type="text" autocapitalize="off" />

5、禁止数字自动识别为电话号码

这个比较有用，因为一串数字在iphone的部分浏览器上会显示成蓝色，样式加成别的颜色也是不生效的。不是我亲测，在微信内部浏览器没问题，但是在safari上有问题，IOS系统版本12.1.4
<div style="color: red">1212312312321323</div>
解决方案
<meta name="format-detection" content="telephone=no" />

6、input type=number之后，pc端出现上下箭头
解决方案
input::-webkit-inner-spin-button {
  -webkit-appearance: none !important;
  margin: 0;
}

7、是图片填充到外层的框内，很好用，直接给图片添加样式。
解决方案
object-fit: cover;
width:100%;
height:100%;

8、手机端按住不放 阻止浏览器默认响应事件 调试
解决方案
//clikMenu 你要点击的事件节点
function touchendmovie(clikMenu){
    var timeOutEvent = 0;
    $(document).on('touchstart',clikMenu,function(e){
        timeOutEvent = setTimeout(function(){
        //这里编写你要执行的事件 },300);
        //这里设置长按响应时间
        e.preventDefault();
    });
    $(document).on('touchmove',clikMenu,function(e){
        clearTimeout(timeOutEvent);
        timeOutEvent = 0;
    });
    $(document).on('touchend',clikMenu,function(e){
        e.stopPropagation();
        if(timeOutEvent != 0 ){
            console.log('这里是点击了一下'); 
        }
        clearTimeout(timeOutEvent); 
    });
}

9、禁止复制、选中文本
解决方案
.el {
  -webkit-user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
   user-select: none;
}

10、input 的placeholder属性会使文本位置偏上
解决方案
line-height: （和input框的高度一样高）---pc端解决方法
line-height：normal ---移动端解决方法
```

####  8 css预处理器

​	1 sass  less

```
	CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。
```

####  9 H5 新增新特性

```
nav , header ,footer ,session 
1  拖拽API
2  input 新增类型
3  视频音频
4  canvas
5  获取定位  谷歌浏览器不行（）  
6  web存储   localStorage sessionStorage
```

```
https://www.cnblogs.com/ainyi/p/9777841.html
H5 新特性
1. 语义化标签：header、footer、section、nav、aside、article
2. 增强型表单：input 的多个 type
3. 新增表单元素：datalist、keygen、output
4. 新增表单属性：placehoder、required、min 和 max
5. 音频视频：audio、video
6. canvas
7. 地理定位
8. 拖拽
9. 本地存储：localStorage - 没有时间限制的数据存储；sessionStorage - 针对一个 session 的数据存储，当用户关闭浏览器窗口后，数据会被删除
10. 新事件：onresize、ondrag、onscroll、onmousewheel、onerror、onplay、onpause
11. WebSocket：单个 TCP 连接上进行全双工通讯的协议
```

#### 10 适配 

```
rem来适配 
1  后期字体大小不适配  就用px
2  rem插件    
```

```
	由于rem是根据根元素的font-size大小而定，所以根据浏览器当前的分辨率改变font-size的值，就可以用rem作为统一单位适配移动端
	下图是不同宽度浏览器对应的font-size,可以引Rem自适应JS适配移动端。
```

![image-20201013185918101](https://vcdn.pharmcube.com/icon-close.png)

#### 11 响应式布局

```
1  不同的终端显示不同的布局   media
2  不同分辨率显示布局一样 （视频）
```

```
@media screen and (max-width: 990px) and (min-width: 768px) {
   css样式
}
```



#### 12  翻译 

```
1  几版语言写几版页面
2  vue-
```



### JAVASCRIPT

#### 13   javascript 数据类型

``` 
基本类型  String (显示)  Number(运算)  Boolean(判断)  Undefined(声明未赋值) == Null(对象的空) Symbol(做键值)
引用类型  Object Array Function

区别
基本类型存在  栈中   用完就销毁    之不能长存
引用类型      堆中   不会自动销毁

引用赋值和浅拷贝和深拷贝

引用赋值   就是 =   引用同一个地址  所有如果改变某个属性  所有引用都改变
浅拷贝   只拷贝一层   [...arr] {...obj}
深拷贝   遍历对象进行递归 ， JSON.stringify , JSON.parse ,  immutable.js
```

```
https://www.jianshu.com/p/cf1e9d7e94fb
1.数据类型：
基本数据类型：String，Boolean，Number，Undefined，Null；
引用数据类型：Object(Array，Date，RegExp，Function)；
基本数据类型和引用数据类型的区别：
    保存位置不同：基本数据类型保存在栈内存中，引用数据类型保存在堆内存中，然后在栈内存中保存了一个对堆内存中实际对象的引用，即数据在堆内存中的地址，JS对引用数据类型的操作都是操作对象的引用而不是实际的对象，如果obj1拷贝了obj2，那么这两个引用数据类型就指向了同一个堆内存对象，具体操作是obj1将栈内存的引用地址复制了一份给obj2，因而它们共同指向了一个堆内存对象；
为什么基本数据类型保存在栈中，而引用数据类型保存在堆中？
1）堆比栈大，栈比堆速度快；
2）基本数据类型比较稳定，而且相对来说占用的内存小；
3）引用数据类型大小是动态的，而且是无限的，引用值的大小会改变，不能把它放在栈中，否则会降低变量查找的速度，因此放在变量栈空间的值是该对象存储在堆中的地址，地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响；
4）堆内存是无序存储，可以根据引用直接获取；
2.深拷贝，浅拷贝
(1)深拷贝和浅拷贝简单解释：
     浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；
(2)区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；
(3)浅拷贝：
//手动实现
function simpleCopy(obj1) {
   var obj2 = Array.isArray(obj1) ? [] : {};
   for (let i in obj1) {
   obj2[i] = obj1[i];
  }
   return obj2;
}
var obj1 = {
   a: 1,
   b: 2,
   c: {
   d: 3
  }
}
var obj2 = simpleCopy(obj1);
obj2.a = 3;
obj2.c.d = 4;
alert(obj1.a); // 1
alert(obj2.a); // 3
alert(obj1.c.d); // 4
alert(obj2.c.d); // 4
//使用Object.assign()实现浅拷贝
let obj1 = {
   a: {
     b: 1
   },
   c: 2
}
let obj2 = Object.assign({},obj1)
obj2.a.b = 3;
obj2.c = 3
console.log(obj1.a.b); // 3
console.log(obj2.a.b); // 3
console.log(obj1.c); // 2
console.log(obj2.c); // 3
//展开运算实现浅拷贝
var obj1={
    a:1,
    b:2,
    c:{
        d:3
    }
}
var obj2={...obj1}
obj2.a=11
obj2.c.d=13
console.log(obj1,obj2)
(4)深拷贝
//递归实现深拷贝
function deepCopy(obj1) {
  var obj2 = Array.isArray(obj1) ? [] : {};
  if (obj1 && typeof obj1 === "object") {
    for (var i in obj1) {
      if (obj1.hasOwnProperty(i)) {
        // 如果子属性为引用数据类型，递归复制
        if (obj1[i] && typeof obj1[i] === "object") {
          obj2[i] = deepCopy(obj1[i]);
        } else {
          // 如果是基本数据类型，只是简单的复制
          obj2[i] = obj1[i];
        }
      }
    }
  }
  return obj2;
}
var obj1 = {
  a: 1,
  b: 2,
  c: {
    d: 3
  }
}
var obj2 = deepCopy(obj1);
obj2.a = 3;
obj2.c.d = 4;
alert(obj1.a); // 1
alert(obj2.a); // 3
alert(obj1.c.d); // 3
alert(obj2.c.d); // 4
//使用JSON.stringify和JSON.parse实现深拷贝
 function deepCopy(obj1){
    let _obj = JSON.stringify(obj1);
    let obj2 = JSON.parse(_obj);
    return obj2;
  }
var a = [1, [1, 2], 3, 4];
var b = deepCopy(a);
b[1][0] = 2;
alert(a); // 1,1,2,3,4
alert(b); // 2,2,2,3,4
缺点：对象里的值为函数无法拷贝
let obj1 = {
   fun:function(){
      alert(123);
   }
}
let obj2 = JSON.parse(JSON.stringify(obj1));
console.log(typeof obj1.fun); // function
console.log(typeof obj2.fun); // undefined
//jquery实现深拷贝
jquery 提供一个$.extend可以用来做深拷贝；
```



#### 14   排序

```
https://segmentfault.com/a/1190000016286789 
sort
冒泡
```

```
1.sort排序
按升序排列
arr.sort(
    function(n1,n2){
    	return n1-n2
})
按降序排列
arr.sort(
	function(n1,n2){
		return n2-n1
})
2.冒泡排序
function bubbleSort(arr) {
    for (var i = 0; i < arr.length; i++) {
        for (var j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[i]) {
                [arr[j], arr[i]] = [arr[i], arr[j]]
            }
        }
    }
}
3.选择排序
function selectSort(arr) {
    for (var i = 0; i < arr.length; i++) {
        var min = i
        for (var j = i + 1; j < arr.length; j++) {
            if (arr[min] > arr[j]) {
                min = j
            }
        }
        if (i != min) {
            [arr[min], arr[i]] = [arr[i], arr[min]]
        }
    }
}
4.快速排序
function quickSort(arr){
  qSort(0, arr.length - 1);
  return arr;
  function qSort(left, right){
    if (left >= right)//两个数相遇则结束该轮排序
      return;
    var key = arr[left];//取最左边的元素作为标识数
    var i = left;
    var j = right;
    while (i != j){//两个数相遇则结束该轮排序
      while (i != j && arr[j] >= key) j--;//j前移
      [arr[j], arr[i]] = [arr[i], arr[j]];
      while (i != j && arr[i] <= key) i++;//i后移
      [arr[j], arr[i]] = [arr[i], arr[j]];
    }
    qSort(left, j - 1);//对标识数前面的数继续该方法排序
    qSort(j + 1, right);//对标识数后面的数继续该方法排序
  }
}
```

#### 15  去重  

```
https://www.cnblogs.com/lewiscutey/p/8269567.html
```

```
Set()方法去重(ES6新增)
function unique(arr){
    return [...(new Set(arr))];
}
```

#### 16 闭包   

```
1  声明局部变量供外部使用，防止变量污染全局
2  闭包因为有函数  所以会存在堆中   可以存储值   一般会用来做缓存
缺点  容易造成内存泄漏  
解决方案  手动清除

3 写法 
	函数嵌套
	内部函数会作为外部函数的返回值
	内部函数因为作用域链可以访问外部函数的变量 会做为内部函数的返回值

代码 
  function fn1(){
          var a = 10
          return function(){
              return  a
          }
      }
```

```
闭包概念：
1. 有一个 A 函数，再 A 函数内部返回一个 B 函数
2. 再 A 函数外部有变量引用这个 B 函数
3. B 函数内部访问着 A 函数内部的私有变量
以上三个条件缺一不可
闭包特点：
1. 作用域空间不销毁
- 优点： 因为不销毁，变量页不会销毁，增加了变量的生命周期
- 缺点： 因为不销毁，会一直占用内存，多了以后就会导致内存溢出
2. 可以利用闭包访问再一个函数外部访问函数内部的变量
- 优点： 可以再函数外部访问内部数据
- 缺点： 必须要时刻保持引用，导致函数执行栈不被销毁
3. 保护私有变量
- 优点： 可以把一些变量放在函数里面，不会污染全局
- 缺点： 要利用闭包函数才能访问，不是很方便
代码：
function fun() {
    var count = 1;
    return function () {
        count++
        console.log(count)
    }
}
var fn = fun()
fn()  /* 2 */
fn()  /* 3 */
```

#### 17 面向对象	--- 封装

```
面向对象是一种编程思想  符合我们的生活逻辑
解
（面向过程）
答案

面向过程也是一种编程思想   数学逻辑的映射   
解  
第一步骤
第二步骤
第三步骤
结果

```

```
面向对象编程，使用构造函数构造对象
1. 先书写一个构造函数
2. 在构造函数内向对象添加一些成员
3.使用这个构造函数创造一个对象（和 new 连用）
4.构造函数可以创建对象，并且创建一个带有属性和方法的对象
5.面向对象就是要想办法找到一个有属性和方法的对象
6.面向对象就是我们自己制造构造函数的过程
代码：
// 1. 先创造一个构造函数
function Person(name, gender) {
  this.age = 18
  this.name = name
  this.gender = gender
}
// 2. 使用构造函数创建对象
var p1 = new Person('Jack', 'man')
var p2 = new Person('Rose', 'woman')
// 3. 使用原型向构造函数添加方法：
Person.prototype.sayHi = function () {
  console.log('hello')
}
p1.sayHi()
// 4. 实例化对象的 __proto__ 和所属的构造函数的 prototype 是一个对象空间
console.log(p1.__proto__ === Person.prototype) // true
// 5. p1和p2都是Person的实例,p1.__proto__ 和 p2.__proto__ 指向的都是 Person.prototype,两个实例化对象p1和p2执行的是同一个方法。即构造函数原型Person.prototype里的方法。
console.log(p1.sayHi === p2.sayHi) // true
```

#### 18 原型链

```
每一个对象都有原型对象 ， 原型对象也有原型对象 ，依次向上，直到Object.prototype如果还没有最会指向null,这样形成一个线性的链就叫做原型链
原型链特点 原型链上的方法和属性 实例可以共享

共享的原因是什么？
实例会有指针  __proto__ 会指向源性对象
```

```
原型链：
实例化对象的__proto__指向其构造函数的prototype,实例化对象的__proto__里面也有一个成员叫做constructor指向当前这个对象所属的构造函数。实例化对象的__proto__的__proto__指向顶级构造函数Object的prototype,实例化对象的__proto__的__proto__里面的constructor指向顶级构造函数Object。Object.prototype就到顶了，Object.prototype 的 __proto__ 就是 null。
原型链的访问原则
访问一个对象的成员的时候,自己没有就会去 __proto__ 中找,如果 __proto__ 里面没有就再去 __proto__ 里面找,一直找到 Object.prototype 里面都没有，那么就会返回 undefiend。
```

#### 19 继承  说话的继承都是为了优化代码，优化性 

```
组合继承 = 借用构造函数继承 + 原型对象继承

 //超类  父类   假继承
 function A(name, age) {
 	this.name = name;
 	this.age = age;
 }
 A.prototype.eat = function () {
	 console.log(this.name + "吃 " + this.name);
 };
Dog.prototype = new A();
Cat.prototype = new A();
 function Dog(name, age) {
 		A.call(this, name, age);
 }
 function Cat(name, age) {
	 A.call(this, name, age);
 }
 var dog1 = new Dog("小白", 3);
 var dog2 = new Dog("小白1", 31);
 var cat1 = new Cat("喵咪", 3);
 console.log(dog1, cat1);
 dog1.eat();
 cat1.eat();
console.log(dog1.eat === dog2.eat); //true
```

```
1.组合继承
function Person() {
    this.name = 'Jack'
}
Person.prototype.sayHi = function () {
    console.log('hello')
}
function Student() {
    Person.call(this)
}
Student.prototype = new Person()
var s1 = new Student()
2.ES6继承
function Person() {
    this.name = 'Jack'
}
Person.prototype.sayHi = function () {
    console.log('hello')
}
// 下面表示创造一个 Student 类，继承自 Person 类
class Student extends Person {
    constructor() {
        // 必须在 constructor 里面执行一下 super() 完成继承 
        super()
    }
}
var s1 = new Student()
```

#### 20   本地存储    

```
cookie  （一般情况下  cookie都是从后台发送的）
web存储  (低版本不兼容)   localStorage （长存）  sesstionStorage (会话 关闭浏览器销毁)

if(localStorage){
	使用localStorage
}else{
	cookie
}
```

```
1.cookie:
cookie是一个以字符串的形式存储数据的位置,在字符串中以key=value的形式出现,每一个key=value是一条数据,多个数据之间以 ; 分割。每一个 HTTP 请求都会在请求头中携带 cookie 到服务端,每一个 HTTP 响应都会在响应头中携带 cookie 到客户端,也就是,cookie 是不需要我们手动设置，就会自动在 客户端 和 服务端之间游走的数据。
读取cookie：
const cookie = document.cookie
console.log(cookie) // 就能得到当前 cookie 的值
设置cookie：
// 下面这个 cookie 数据会在 2043 年 12 月 18 日 12 点以后过期，过期后会自动消失
document.cookie = 'b=200;expires=Thu, 18 Dec 2043 12:00:00 GMT";'
删除cookie：
// 因为 cookie 不能直接删除
// 所以我们只能把某一条 cookie 的过期时间设置成当前时间之前
// 那么浏览器就会自动删除 cookie
document.cookie = 'b=200;expires=Thu, 18 Dec 2018 12:00:00 GMT";'
2.localStorage 本地存储：
没有过期时间,不会跟随服务器发送,大小5M,不用在服务器下运行。
// 设置
localStorage.setItem('item', 'abc')
// 获取
console.log(localStorage.getItem('item'))
// 删除
localStorage.removeItem('item')
// 清空
localStorage.clear()
3.sessionStorage 本地存储:
会话结束就没有了,不会跟随服务器发送,大小5M,不用在服务器下运行,写法和localStorage完全一样。
// 设置
sessionStorage.setItem('item', 'abc')
// 获取
console.log(sessionStorage.getItem('item'))
// 删除
sessionStorage.removeItem('item')
// 清空
sessionStorage.clear()
```



#### 21  ajax  

```
前后端交互技术  核心两个
XMLHttpRequest   ---  $.ajax  axios
fetch  -- fetch

1 ajax 原理
  1） 获取核心对象  做兼容
  2） 发送请求   xhr.open("methods",url,true)
  3)  发送参数   xhr.send(null)
  4)  监听变化触发函数   xhr.onreadystatechange
 
2 axios 二次分装    
	请求拦截器  修改参数类型 ， 统一传固定参数 。。。
	相应拦截器  错误几种处理  

3 $.ajax  当你想用 jsonp的时候  用封装$.ajax 
```

```
1. ajax：
ajax全名async javascript and XML(异步的javascript和XML),客户端给服务端发送消息的工具，以及接受响应的工具。
(1)创建一个 ajax 对象
const xhr = new XMLHttpRequest()
(2)配置链接信息
// xhr.open('请求方式', '请求地址', 是否异步默认 true 表示异步false 表示同步)
xhr.open('get', './data.php')
(3)发送请求
xhr.send()
(4)获得相应数据
// ajax状态码 xhr.readyState,只有当 readyState === 4 的时候，我们才可以正常使用服务端给我们的数据
// 记录http状态码 xhr.status,200 ~ 299 表示本次请求成功了
// readyStateChange事件专门用来监听ajax对象
// responseText用来记录服务端给我们的响应体内容的
xhr.onreadyStateChange = function () {
  if (xhr.readyState === 4 && /^2\d{2|$/.test(xhr.status)) {
    console.log(xhr.responseText)
  }
}
(5)发送参数
// get 请求的参数就直接在 url 后面进行拼接就可以
xhr.open('get', './data.php?a=100&b=200')
// post 请求的参数是携带在请求体中的,必须要先设置一下请求头中的 content-type
// application/x-www-form-urlencoded 表示的数据格式就是 key=value&key=value
xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded')
xhr.send('a=100&b=200')
2. axios:
(1)设置拦截器
import axios from "axios";
const fetchData = axios.create({
    baseURL: "http://localhost:3000", // 请求地址前缀
    withCredentials: true, // 允许携带cookie
});
//添加请求拦截器
fetchData.interceptors.request.use(
    function (config) {
        if (config.method == "get") {
            config.params = {
                ...config.params,
                token: JSON.parse(localStorage.getItem("user")).token,  //携带token
                cookie: JSON.parse(localStorage.getItem("user")).cookie,  //携带cookie
            };
        }
        if (config.method == "post") {
            config.data = {
                ...config.data,
                token: JSON.parse(localStorage.getItem("user")).token,  //携带token
                cookie: JSON.parse(localStorage.getItem("user")).cookie,   //携带cookie
            };
        }
        return config;
    },
    function (error) {
        //请求错误时做些事
        return Promise.reject(error);
    }
);
//添加响应拦截器
fetchData.interceptors.response.use(
    function (response) {
        //对响应数据做些事
        return response;
    },
    function (error) {
        //响应错误时做些事
        return Promise.reject(error);
    }
);
export default fetchData;
(2)二次封装
// 导入拦截器
import fetchData from "./fetchData";
// get请求用params传参
export async function getPlayList(data = {}) {
  return await fetchData.get("/top/playlist", {
    params: data,
  });
}
// post请求用data传参
export async function login(data) {
  return await fetchData.post("/login/cellphone", data);
}
3. jsonp:
(1)script 标签的 src 属性本质就是请求一个外部资源，是不受到同源策略的影响的。并且请求回来的东西是一个字符串，浏览器会把这个字符串当作 js 代码来执行。所以我们就可以利用这个 script 标签的 src 属性来进行跨域请求。
(2)使用Jquery封装函数$.ajax
$.ajax({
    url: "http://127.0.0.1:8081/list",
    dataType: "jsonp",
    success: (res) => {
    	console.log(res)
    },
});
```

#### 22 防抖 和 节流  

```
1 使用场景 
   1 ) 搜索的时候 ， 很容易重复触发请求，怎么避免这个问题
   2 ) 根据移动坐标来触发验证  ， 滑动验证码
   
https://segmentfault.com/a/1190000018428170    看看文章 （）
```

```
1. 防抖：
对于短时间内连续触发的事件（如滚动事件），防抖的含义就是让某个时间期限内，事件处理函数只执行一次。
function debounce(fn,delay){
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer) 
        }
        timer = setTimeout(fn,delay) // 简化写法
    }
}
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log('滚动条位置：' + scrollTop);
}
window.onscroll = debounce(showTop,1000)
2. 节流：
如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。
function throttle(fn,delay){
    let valid = true
    return function() {
       if(!valid){
           //休息时间 暂不接客
           return false 
       }
       // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false
        setTimeout(() => {
            fn()
            valid = true;
        }, delay)
    }
}
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log('滚动条位置：' + scrollTop);
}
window.onscroll = throttle(showTop,1000) 
```



#### 23  事件委托   提高性能

```
1  利用的是冒泡原理 ，将事件注册给父辈组件，因为冒泡点击本身的时候父组件会触发，可以通过判断事件源，来判断是谁触发的从而实现事件委托
2  减少了事件注册   ， 动态添加的元素依然会享有事件
```

```
事件委托：
可以给未来元素添加事件
<body>
  <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
  </ul>
  <script>
  	var oUl = docuemnt.querySelector('ul')   
    oUl.addEventListener('click', function (e) {
      e = e || window.event
      var target = e.target || e.srcElement
      if (target.nodeName === 'LI') {
        console.log('我是 li，我被点击了')
      }
    })
  </script>
</body>
```



#### 24 事件流    

```
冒泡  --  从内向外  -- 事件委托
捕获  --  从外向内  --  改热键 

div.addEventListener("click",function(){},false) --  removeEventLisener
div.onclick=function(){}
```

```
1. 冒泡：
就是从事件目标的事件处理函数开始，依次向外，直到 window 的事件处理函数触发，也就是从下向上的执行事件处理函数
2. 捕获：
就是从 window 的事件处理函数开始，依次向内，直到事件目标的事件处理函数执行，也就是从上向下的执行事件处理函数
事件触发默认冒泡，从内向外触发。
阻止冒泡的几种方式：
(1) e.stopPropagation() 点击只出现li
<ul>
    <li>1</li>
</ul>
<script>
    var ul = document.querySelector('ul')
    var li = document.querySelector('li')
    li.addEventListener('click', function (e) {
        e.stopPropagation()
        console.log('li')
    })
    ul.addEventListener('click', function () {
        console.log('ul')
    })
</script>
(2)e.cancelBubble = true 点击只出现li
<ul>
    <li>1</li>
</ul>
<script>
    var ul = document.querySelector('ul')
    var li = document.querySelector('li')
    li.addEventListener('click', function (e) {
        e.cancelBubble = true
        console.log('li')
    })
    ul.addEventListener('click', function () {
        console.log('ul')
    })
</script>
(3)事件监听第三个参数true,事件捕获，默认false,事件冒泡。冒泡先出现li,再出现ul。捕获先出现ul,再出现li。
<ul>
    <li>1</li>
</ul>
<script>
    var ul = document.querySelector('ul')
    var li = document.querySelector('li')
    li.addEventListener('click', function (e) {
        console.log('li')
    })
    ul.addEventListener('click', function () {
        console.log('ul')
    },true)
</script>

```



#### 25  跨域 

```
1  同源策略    端口号  协议  域名     部署到同原
2  cors 服务器设置响应头    允许访问      nginx
3  使用webpack代理 （开发过程中有用）    打包之后不生效
    proxy: {
        "/api": {
        target: "http://192.168.x.xxx:8090", // 要访问的接口域名
        ws: true, // 是否启用websockets
        changeOrigin: true, //开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题
        pathRewrite: {
        "^/api": "", //这里理解成用'/api'代替target里面的地址,比如我要调用'http://40.00.100.100:3002/user/add'，直接写'/api/user/add'即可
        },
        },
    },
 4  jsonp  原理    纯前端技术跨域  （需要后端配合）
 5  iframe 跨域
 6  websocket  可以做跨域
```

```
https://juejin.im/post/6844904126246027278?utm_source=wechat_session&utm_medium=social&utm_oi=665117609675198464#heading-28
1 同源策略：请求协议/域名/端口号全部相同。
2 CORS：跨域资源共享(浏览器自带机制)
跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。对于前端来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求,实现CORS通信的关键是服务器。
Node 中的解决方案
直接使用中间件
const cors = require("koa-cors");
app.use(cors());
传递cookie前端需设置 withCredentials: true,后端需设置Access-Control-Allow-Credentials为true,Access-Control-Allow-Origin不为*
3 nginx反向代理
(1)安装nginx
(2)配置nginx，把localhost:8080和localhost:8000统一配置在统一服务器local.test(自定义域名)下。
server {
        listen 80;
        server_name local.test;
        location /api {
            proxy_pass http://localhost:8080;
        }
        location / {
            proxy_pass http://localhost:8000;
        }
}
(3)重启nginx
(4)前端请求
<script> 
	axios.defaults.withCredentials = true; 
	login.onclick = () => { 
		axios.post("/api/login");
	};
</script>
4 使用webpack代理(开发过程中有用,打包之后不生效)
配置webpack中的devServe
devServer: {
    open: true,
    host: 'localhost',
    port: 8000,
    https: false,
    hotOnly: false,
    proxy: {
        // 配置跨域
        '/api': {
            target: 'http://localhost:8080/',  // 要访问的接口域名
            ws: true,  // 是否启用websockets
            changOrigin: true, //开启代理
       		pathRewrite: {
        	'^/api': '' //这里理解成用'/api'代替target里面的地址,比如我要调	用'http://localhost:8080/login'，直接写'/api/login'即可
        	}
        }
    },
    before: app => { }
}
5 jsonp跨域
(1)script 标签的 src 属性本质就是请求一个外部资源，是不受到同源策略的影响的。并且请求回来的东西是一个字符串，浏览器会把这个字符串当作 js 代码来执行。所以我们就可以利用这个 script 标签的 src 属性来进行跨域请求。
<script>
    var script=document.createElement('script')
    function getData(data){
        console.log(data)
    }
    script.src='http://localhost:8080?callback=getData'
    document.body.appendChild(script)
</script>
(2)使用Jquery封装函数$.ajax
$.ajax({
    url: "http://127.0.0.1:8081/list",
    dataType: "jsonp",
    success: (res) => {
    	console.log(res)
    },
});

```

#### 26  当你输入网址的时候经历了什么？

```
https://segmentfault.com/a/1190000006879700  
```

```
1.DNS解析:DNS解析的过程就是网址到IP地址的转换,当发送请求时，可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡。
2.TCP连接
TCP/IP 协议
三次握手：
(1)客户端发送一个消息给到服务端
(2)服务端回给客户端一个消息
(3)客户端再回给服务端一个消息
四次挥手：
(1)客户端发送一个我要断开的消息给服务端
(2)服务端接受到以后发送一个消息告诉客户端我已经进入关闭等待状态
(3)服务端再次发送一个消息告诉客户端，这个是我的最后一次消息给你，当我再接受到消息的时候就会关闭
(4)客户端接受到服务端的消息以后，告诉服务器，我已经关闭，这个是给你的最后一个消息
3.发送HTTP请求
每一个请求都会有一个请求报文(请求行，请求头，请求空行，请求体)
完整请求报文
(1)请求行
POST /user HTTP/1.1     
# POST 请求方式
# /user 请求URL（不包含域名）
# HTTP/1.1 请求协议版本    
(2)请求头
user-agent: Mozilla/5.0 # 产生请求的浏览器信息
accept: application/json # 表示客户端希望接受的数据类型
Content-Type: application/x-www-form-urlencoded # 客户端发送的实体数据格式
Host: 127.0.0.1 # 请求的主机名（IP） 
(3)请求空行
#（此处必须有一空行
(3)请求体
name=world 
4.服务器处理请求并返回HTTP报文
响应报文(状态行，响应头，响应体)
(1)状态行
HTTP/1.1 200 OK
# HTTP/1.1 服务器使用的 HTTP 协议版本
# 200 响应状态码
# OK 对响应状态码的简单解释
(2)响应头
Date: Jan, 14 Aug 2019 12:42:30 GMT # 服务器时间
Server: Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.4.45 # 服务器类型
Content-Type: text/html # 服务端给客户端的数据类型
Content-Length: 11 # 服务端给客户端的数据长度
(3)响应体
hello world
# 服务端给客户端的响应数据
5.浏览器解析渲染页面
   浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为reflow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。
6.连接结束
```



#### 27  GET POST 区别

```
1  post  上传   都可以用post
2  get   明文请求     jsonp必须用get    请求内容在地址栏显示  不安全   
```

```
1、传送方式：get通过地址栏传输，post通过报文传输。
2、传送长度：get参数有长度限制（受限于url长度），而post无限制
3、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；
```

#### 28 this指向

```
普通函数的this   谁调用指向谁     把谁找到   就看.前面的对象   全局window可以省略的
箭头函数的this会指向上层环境  不会改变
```

```
函数内部的 this 只和函数的调用方式有关系，和函数的定义方式没有关系
1.全局定义的函数直接调用，this => window
2.对象内部的方法调用，this => 调用者
3.定时器的处理函数，this => window
4.事件处理函数，this => 事件源
5.自调用函数，this => window
6.call 和 apply 和 bind强行改变this指向
函数名.call(要改变的 this 指向，要给函数传递的参数1，要给函数传递的参数2， ...)
函数名.apply(要改变的 this 指向，[要给函数传递的参数1， 要给函数传递的参数2， ...])
bind方法不会立即执行函数，而是返回一个已经改变了 this 指向的函数
var newFn = 函数名.bind(要改变的 this 指向);
newFn(传递参数)
7.在框架组件中this指向当前组件的实例化对象
```



#### 29  webpack  基础

```
entry :入口      多页应用 多入口多出口
output: 出口
module:{   loader
	rules:[]
}
plugins:[ ],
devServer:{}  //webpack服务器
```

```
const path = require("path");
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  mode: "development",
  entry: "./src/main.js",     //入口文件
  output: {                    //口文件
    filename: "main.js",
    path: path.join(__dirname, "../dist"),
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ["style-loader", "css-loader"],
      },
      {
        test: /\.scss$/,
        use: [
          {
            loader: "style-loader", // 将 JS 字符串生成为 style 节点
          },
          {
            loader: "css-loader", // 将 CSS 转化成 CommonJS 模块
          },
          {
            loader: "sass-loader", // 将 Sass 编译成 CSS
          },
        ],
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "./index.html"
    }),
  ],
  devServer: {
    // contentBase: path.join(__dirname, "../dist"),
    port: 3000,   //端口号
    open: true,  //是否自动打开浏览器
    hot: true,  // 热更新
    proxy: {
      '/api': {// '/api':匹配项
        target: 'http://www.baidu.com',// 接口的域名
        // secure: false,// 如果是https接口，需要配置这个参数
        changeOrigin: true,// 如果接口跨域，需要进行这个参数配置
        // pathRewrite: {// 如果接口本身没有/api需要通过pathRewrite来重写了地址
        //   '^api': ''
        // }
      }
    }
  }
};

```



#### 30  call apply  bind 

```
统一的作用都是  修改this指向
call(对象,参数1，参数2，参数3) 直接调用
apply(对象，[])  直接调用
bind(对象，参数1，参数) 必须还需要加（）调用
```

### ES6

#### 31 promise

```
1 解决异步回调问题  
2  因为  我们开发程序 有可能是有关联的 
	例如   可以程序 有三步组成   第一步的结果会影响到第二步 ， 第二步结果会影响第三步  	
3 Promise.then().then().then().catch()

new Promise((resolve,reject)=>{
	resove('ok') // 传递给.then
	reject(err)  // 传递catch
})

async  --- await

async function () { }  返回promise对象
await 将异步转成同步

Promise.all()
Promise.race()
```

```
1.promise语法
new Promise(function (resolve, reject) {
  // resolve 表示成功的回调
  // reject 表示失败的回调
}).then(function (res) {
  // 成功的函数
}).catch(function (err) {
  // 失败的函数
})
2.async/await语法
async function fn() {
  const res = await promise对象
}
```



#### 32  let const var  区别

```
let,const 会产生块及作用域 ，声明的变量就是私有的
var  变量提升（预解析）  let const 没有
let  可以修改 但是不可重复声明  
const  不可以修改    我们一般定义 常量  配置属性

使用的一般我们会根据 作用域来选    -----   解决了 变量徐然全局的问题  ----- 有点类似闭包的特性

```



#### 33 箭头函数 

```
1 使用情况  在vue和react或者其他框架里面，我们一般情况下  this都应该指向当前组件 ， 如果用普通函数会导致this指向不明确，所以用箭头函数比较合适
2 箭头函数的this始终指向它的外部环境，不会发生改变
3 let  foo = () => {}      后面有没有大括号是两种  如果有大括号就是普通函数   如果不加大括号  自动加return
4 不能能做构造函数    因为this指向固话
5 箭头函数没有 arguments对象 （获取实参的集合）， 我们可以通过 ...拓展运算符来模拟实参集合
```

```
 箭头函数只能简写函数表达式，不能简写声明式函数
 语法： (函数的行参) => { 函数体内要执行的代码 }
 箭头函数内部没有 this，箭头函数的 this 是上下文的 this
 箭头函数内部没有 arguments 这个参数集合
 函数的行参只有一个的时候可以不写 ()其余情况必须写
 函数体只有一行代码的时候，可以不写 {}，并且会自动 return
```



#### 34  解构赋值

```
a=10  b=11   
[b,a]= [a,b]
```

```
解构对象
const obj = {
  name: 'Jack',
  age: 18,
  gender: '男'
}
let { name, age, gender } = obj
解构数组
const arr = ['Jack', 'Rose', 'Tom']
let [a, b, c] = arr
```



#### 35 模板字符串 

```
` ${} `
```

```
let num = 100
let str = `hello${num}world${num}`
console.log(str) // hello100world100
```

#### 36  新增方法



#### 37  class  类

```
class Person {}
class Man extends Preson{
	constructor(){
		super()
	}
}
```

```
// 下面表示创造一个 Student 类，继承自 Person 类
class Student extends Person {
    constructor () {
        // 必须在 constructor 里面执行一下 super() 完成继承 
        super()
    }
}
```

#### 38 Set ,Map   去重

```
arr = [...new Set(arr)]
```

```
https://www.cnblogs.com/leftJS/p/11080962.html
1.set类似于数组，但是成员的值都是唯一的，没有重复的值。
(1)实例对象方法
add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。
delete(value)：删除某个值，删除成功返回true，否则返回false。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。
const mySet = new Set(['a', 'a', 'b', 1, 2, 1])
console.log(mySet)  // {'a', 'b', 1, 2}   
myset.add('c').add({'a': 1})
console.log(mySet) // {'a', 'b', 1, 2, 'c', {a: 1}} 
console.log(mySet.size)     // 6
mySet.has(2)     // true
(2)遍历方法
keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回键值对的遍历器。
forEach()：使用回调函数遍历每个成员。
(3)数组去重
function unique(arr){
    return [...(new Set(arr))];
}
2.map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。
(1)map对象的方法
set(key, val): 向Map中添加新元素
get(key): 通过键值查找特定的数值并返回
has(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false
delete(key): 通过键值从Map中移除对应的数据
clear(): 将这个Map中的所有元素删除
const m1 = new Map([['a', 111], ['b', 222]])
console.log(m1) // {"a" => 111, "b" => 222}
m1.get('a')  // 111
const m2 = new Map([['c', 3]])
const m3 = new Map(m2)
m3.get('c') // 3
m3.has('c') // true
m3.set('d', 555)
m3.get('d') // 555
(2)遍历方法
keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员
(3)数组去重
function unique(arr) {
    //定义常量 res,值为一个Map对象实例
    const res = new Map();
    //返回arr数组过滤后的结果，结果为一个数组
    //过滤条件是，如果res中没有某个键，就设置这个键的值为1
    return arr.filter((a) => !res.has(a) && res.set(a, 1))
}

```



#### 39   ... 拓展运算符   浅拷贝

```
let arr = [1,2,3,4,5]
let arr1 = [...arr] 浅拷贝
let obj = {name:"zzz"}
let obb1 = {...obj} 
```



####  40  symbol  唯一   用做key值

```
1.Symbol 本质上是一种唯一标识符，可用作对象的唯一属性名，这样其他人就不会改写或覆盖你设置的属性值。
2.声明方法：let id = Symbol("id");
3.Symbol 数据类型的特点是唯一性，即使是用同一个变量生成的值也不相等。
let id1 = Symbol('id');
let id2 = Symbol('id');
console.log(id1 == id2);  //false
4.Symbol 数据类型的另一特点是隐藏性，for···in，object.keys() 不能访问
```



### Jquery

 1  选择器   

  2 简单动画    animate   hide show    slideUp slideDown   

 3  attr   removeAttr

 4  ajax

### Vue与Jquery区别  

```
jquery开发 针对 每次修改dom  所有的思想是对于dom的修改, 好性能  
Vue  MVVM  ,虚拟dom , 组件化开发会大大提高开发效率，维护效率，提高组减的复用， 自带很多指令，可以直接遍历dom，所达到修改数据后，视图会自动更新，
vue  可以做单页应用，这样可以大量的减少http请求
vue  可以有想成缓存组件，更全面的 ui框架提供
vue  官方提供脚手架，当我开发的时候可以组件化，打包之后更是压缩文件，省去了我们原生开发还需要手动压缩
vue  逻辑实现比较简单，只要对数据增删改查就可以实现页面的增删改查
```

### 其他

####   41 BFC(块级格式化上下文)

```
BFC(块级格式化上下文):它是一个独立的渲染区域，只有块级元素参与， 它规定了BFC内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
BFC的布局规则（规定、标准）：
    一、BFC内部的Box会在垂直方向，一个接一个地放置。
    二、Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（按照最大margin值设置）
    三、每个元素的margin box的左边， 与包含块border box的左边相接触
    四、BFC的区域不会与float box重叠。
    五、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。
    六、计算BFC的高度时，浮动元素也参与计算
BFC的触发条件：
    根元素(html)
    float属性不为none
    position为absolute或fixed
    display为inline-block, table-cell, table-caption, flex, inline-flex
    overflow不为visible
应用：
    清除浮动
    三栏布局
```

#### 42 MVC,MVP,MVVM

```
1.MVC:
M:Model
V:View
C:ControllerPresenter
调用关系：用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller；Controller会对来自View数据进行预处理、决定调用哪个Model的接口；然后由Model执行相关的业务逻辑；当Model变更了以后，会通过观察者模式通知View；View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。
2.MVP
M:Model
V:View
P:Presenter
调用关系：和MVC模式一样，用户对View的操作都会从View交移给Presenter。Presenter会执行相应的应用程序逻辑，并且对Model进行相应的操作；而这时候Model执行完业务逻辑以后，也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，通过View提供的接口更新界面。
3.MVVM
M:Model
V:View
VM:Model of View
调用关系：MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。
```

#### 43 检测数据类型

```
1.typeof
对于基本类型，除 null 以外，均可以返回正确的结果。
对于引用类型，除 function 以外，一律返回 object 类型。
对于 null ，返回 object 类型。
对于 function 返回  function 类型。
2.instanceof
instanceof 检测的是原型,instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。
function F(){}
var f=new F()
console.log(f instanceof F) //true
[] instanceof Array; // true
[] instanceof Object; // true
3.constructor
console.log(''.constructor)   //ƒ String() { [native code] }
4.toString
console.log(Object.prototype.toString.call(''))   //[object String]
```

#### 44 git

```
1.GIT 初始化
# git 初始化的指令
$ git init
2.GIT 暂存区
# 把文件夹下的 index.txt 文本放在暂存区
$ git add index.txt
# 把文件夹下所有的内容都放在暂存区
$ git add .
3.GIT 历史区
# 把暂存区的内容放到历史区
$ git commit -m "我是第一个版本"
# 查看当前历史区版本信息
$ git log
4.GIT 分支
# 开辟一个 login 分支
$ git branch login
# 查看当前分支情况
$ git branch
# 切换到 login 分支
$ git checkout login
# 把 login 的内容合并到自己的分支(需要切换到其他主分支master)
$ git merge login
# 删除 login 分支(需要切换到其他分支)
$ git branch -d login
5.GIT 克隆
# 直接克隆仓库
$ git clone https://github.com/jquery/jquery.git
6.GIT 下拉
# 拉取远程最新代码
$ git pull
7.上传
# 上传内容
$ git push -u origin master
# 表示把内容上传到 origin 这个地址
# master 是上传到远程的 master 分支
# 第二次上传
$ git push
```

#### 45 sass和less

```
定义变量的符号不同，less 是用@，sass 使用\$
变量的作用域不同，less 在全局定义，就作用在全局，在代码块中定义，就作用于整个代码块。而 sass 只作用域全局。
```

#### 46 nodejs

```
1.核心模块
(1)http模块（搭建服务器）
const http = require("http");
// request  请求对象  --- 获取请求对象的资源
// responese 相应对象  --- 我需要给前端返回什么
http
  .createServer(function (req, res) {
      console.log(req.url, "res");
      console.log(req.headers,"header")
      res.end("ok");  // 必须要有结尾的
  })
  .listen(8089, function () {
    console.log("启动成功" + 8089);
  });
(2)url模块
cosnt url = require("url")
url.parse(地址,true/false)  // 地址栏转成对象    true表示将query字符串转对象
url.toString()        // 讲对象转成字符串
(3)path模块
path.resolve('资源路径','资源路径')   会拼接绝对路径  会自带 当前跟目录
path.join() 路径合并  不会携带根目录
__dirname  获取当前根目录的绝对路径
(4)fs模块
fs 分同步异步
异步  一般都有回调函数   结果为回调函数的参数
同步  返回值为回调函数的解构
fs.writeFile()
fs.WirteFileSync()
fs.readFile()
fs.readFileSync()
2.commonjs规范
暴露模块     module.exports    export default     export
加载模块	 require           import from       import {} from
3.使用express
const express = require("express");
const app = express();
// app.use()
// 所有的请求都会经过这个回调函数
app.use(function (req, res, next) {
  res.header("Access-Control-Allow-Origin", "*");
  next();
});
// post请求参数
// 作用向req.body 添加post请求参数
app.use(express.urlencoded());   // application/x-www-form-urlencoded
app.use(express.json());         //application/json
// 路由
app.get(function(req,res){
	请求参数  req.query
})
app.listen(8080, function () {
  console.log("启动8080");
});	
4.上传文件
const multer = require("multer");
let destUrl = path.join(__dirname, "../", "public/imgs");
const upl = multer({
  dest: destUrl, //生成图片的路径
});
router.post("/", upl.any("file"), function (req, res) {
  console.log(req.files, "file");
  res.send({
    code: 200,
    msg: "上传成功",
    imgs: imgs,
  });
});
5. mongoose
// 连接数据库
const mongoose = require("mongoose");
const url = "mongodb://127.0.0.1/topic"; // 数据库名默认端口号 27017
mongoose.connect(url);
mongoose.connection.once("open", () => {
  console.log(url + "数据库链接成功");
});
module.exports = mongoose;
// 导出数据模型
const mongoose = require("./mongoose");
const { Schema } = mongoose;
let personSchema = new Schema({
  username: String,
  pass: String,
  create_at: String,
});
let UsersModel = mongoose.model("user", personSchema, "users"); // "users"数据表名
module.exports = UsersModel;
```

#### 47 react-hooks

```
常用hooks
1.useState()
当给 setCount 传入一个与 count 相同的原始值时，组件不会重新渲染。当传递一个对象时，无论是否一样都会渲染
useState()方法可以传递值也可以传递函数，可延迟初始化，此函数在多次渲染时只运行一次。
2.useEffect
函数组件中执行副作用操作。副作用: 数据获取，数据订阅，以及手动更改 React 组件中的 DOM 都属于副作用。
3.useMemo
使用 useMemo 方法可以避免无用方法的调用,
4.useCallback
useCallback 解决的是传入子组件参数过度变化导致子组件过度渲染的问题
5.useContext
用来向所有后代组件传递 props
6.useRef
获取组件实例对象或者是DOM对象
```

#### 48 缓存

```
强制缓存优先于协商缓存进行
1.强制缓存
Cache-Control优先于Expires
2.协商缓存
协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304，继续使用缓存。
Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
If-None-Match 是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 200
Etag / If-None-Match 优先级高于 Last-Modified / If-Modified-Since
3.存储位置
内存缓存优先硬盘缓存
在浏览器中，浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存。
```

#### 49 数组扁平化

```
https://www.cnblogs.com/wind-lanyan/p/9044130.html
```

#### 50 通用柯里化函数

```
//toString方法如果是直接调用那就返回当前函数的字符串，如果等于一个函数那就返回一个函数是直接可以被调用的
//通用的柯力化函数
function curry(){
    //首先收集当前第一次传来的参数
    let _args = Array.prototype.slice.call(arguments)
    //收集二次或多次函数调用参数
    let _collectArgs = function (){
        _args.push(...arguments)
        return _collectArgs
    }
    //难点 _collectArgs.toString()这样直接返回当前的函数的字符串 例如@1 
    //难点  _collectArgs.toString = function(){} 返回这个函数会在自己执行
    //难点toString隐式转换的特性
    //闭包缓存当前参数
    //还可以通过fn.length做性能优化
    _collectArgs.toString = function(){
        return _args.reduce((a,b)=>{
            return a+b
        })
    }
    return _collectArgs
}
//当传入不同的任何格式参数都参与计算
//curry(1,2)(2)(3)
console.log(curry(1)(2)(3))
//例如@1
//当前的函数变成字符串修改里面的内容 还有就是返回当前对象类型
function x() { alert('asdf'); }
eval(x.toString().replace('asdf','hello 打工人'));
x();

————————————————
版权声明：本文为CSDN博主「wy勇敢的心」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wangyun_gogo/article/details/109453414
```

#### 51有效大括号（leetcode 20）

```
 var isValid = function(str){
    var map = {
      "{":"}",
      "[":"]",
      "(":")"
    }
    if(str.length % 2 === 1) return false;
    var res = [];
    for(var i = 0;i < str.length;i++){
      if(map[str[i]]){
        res.push(str[i]);
      } else {
        var a = res[res.length-1];
        if(map[a] == str[i]) {
          res.pop()
        } else {
          return false;
        } 
      }
    }
    return res.length===0;
  }
```

#### 52检索url参数

```
  function query() {
        let url = window.location.search.split("?")[1];
        let params = url.split("&");
        const param = {};
        params.forEach((i) => {
            let item = i.split("=");
            param[item[0]] = item[1];
        });
        console.log(param);
        return param;
    }
```

#### 53大数相加

```
 function bigSum(a, b) {
        // 已 12345 和 678 为例
        // 我们需要先把他们转换为位数相同，不够补零，记住要统一加一位，为了两个最大的位数相加后可能需要进位
        // 12345 =>  012345    678 => 000678
        // 然后让各自的个位个位相加，十位与十位相加   5 + 8 = 3  （1为进位） 4 + 7 + 1 = 2 （1） .....
        a = '0' + a
        b = '0' + b
        let aArr = a.split('')
        let bArr = b.split('')
        let carry = 0
        let res = []
        let length = Math.max(aArr.length, bArr.length)
        let distance = aArr.length - bArr.length
        if (distance > 0) {
            for (let i = 0; i < distance; i++) {
                bArr.unshift('0');
            }
        } else {
            for (let i = 0; i < Math.abs(distance); i++) {
                aArr.unshift('0');
            }
        }
        for (let i = length - 1; i >= 0; i--) {
            let sum = Number(aArr[i]) + Number(bArr[i]) + Number(carry)
            carry = sum >= 10 ? 1 : 0
            sum = sum >= 10 ? parseInt(sum % 10) : sum
            res.unshift(sum)
        }
        return res.join('').replace(/^0/, '')
    }
    console.log(bigSum('9007199254740993', '1'))
// 注意： 传参时就需传入字符串，如果是数字类，在传参时就已经出现精度丢失

https://www.jianshu.com/p/c373943f0e9e
```

#### 54 http协议

```
1.http/1.0
   限制每次连接只处理一个请求，无状态：协议对于事务处理没有记忆能力。客户端向服务器请求服务时，只需传送请求方法和路径。HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。
2.http/1.1
	增加了持久连接的方法，在一个TCP连接上可以传输多个http请求，只要浏览器或者服务器没有明确断开，该TCP连接会一直保持。浏览器为每个域名最多维护6个TCP持久连接。
3.http/2.0
	影响http/1.1效率的三个主要因素：TCP的满启动、多条TCP连接竞争带宽和队头堵塞。
	引入多路复用机制：同一个连接并发处理多个请求。通过在协议栈中添加二进制分帧层来实现。能够实现请求的优先级、服务器推送、头部压缩等特性。
	头部压缩：使用HPACK算法进行压缩。
	服务器推送：页面请求资源a.css，接到服务器资源同时会返回a.js，存到缓存中，下次不用重复访问服务器。
4.https
HTTPS 在传输的过程中会涉及到三个密钥：
- 服务器端的公钥和私钥，用来进行非对称加密
- 客户端生成的随机密钥，用来进行对称加密
一个 HTTPS 请求实际上包含了两次 HTTP 传输，可以细分为 8 步。
1. 客户端向服务器发起 HTTPS 请求，连接到服务器的 443 端口
2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3. 服务器将自己的公钥发送给客户端。
4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么 HTTPS 传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为 client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS 中的第一次 HTTP 请求结束。
5. 客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7. 然后服务器将加密后的密文发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成。
```

